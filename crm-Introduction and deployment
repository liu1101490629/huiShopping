一．项目搭建
1.项目基本结构、
这是一个web项目
搭建ssm框架所需要的配置文件，在resources下generatorConfig.xml mybatis的自动生成类的配置文件
generatorConfiguration.Xml配置文件如下：
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!--数据库驱动-->
    <classPathEntry    location="D:/repository/mysql/mysql-connector-java/5.1.39/mysql-connector-java-5.1.39.jar"/>
    <context id="DB2Tables"    targetRuntime="MyBatis3">
        <commentGenerator>
            <property name="suppressDate" value="true"/>
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>
        <!--数据库链接地址账号密码-->
        <jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/crm01" userId="root" password="root">
        </jdbcConnection>
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>
        <!--生成Model类存放位置-->
        <javaModelGenerator targetPackage="com.shsxt.crm.po" targetProject="C:/Users/admin/IdeaProjects/shsxt_crm/src/main/java">
            <property name="enableSubPackages" value="true"/>
            <property name="trimStrings" value="true"/>
        </javaModelGenerator>
        <!--生成映射文件存放位置-->
        <sqlMapGenerator targetPackage="com.shsxt.crm.mapper" targetProject="C:/Users/admin/IdeaProjects/shsxt_crm/src/main/java">
            <property name="enableSubPackages" value="true"/>
        </sqlMapGenerator>
        <!--生成Dao类存放位置-->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.shsxt.crm.dao" targetProject="C:/Users/admin/IdeaProjects/shsxt_crm/src/main/java">
            <property name="enableSubPackages" value="true"/>
        </javaClientGenerator>


    </context>
</generatorConfiguration>


Jdbc.properties的连接数据库配置文件


jdbc.driver=com.mysql.jdbc.Driver
#开发数据库
#jdbc.url=jdbc:mysql://127.0.0.1:3306/crm01?useUnicode=true&characterEncoding=utf8
#远程数据库
jdbc.url=jdbc:mysql://192.168.48.101:3306/crm01?useUnicode=true&characterEncoding=utf8
jdbc.username=root
jdbc.password=root


Log4j.Properties配置文件 日志打印
log4j.rootLogger=DEBUG, Console  
#Console
log4j.appender.Console=org.apache.log4j.ConsoleAppender  
log4j.appender.Console.layout=org.apache.log4j.PatternLayout  
log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  
log4j.logger.java.sql.ResultSet=INFO  
log4j.logger.org.apache=INFO  
log4j.logger.java.sql.Connection=DEBUG  
log4j.logger.java.sql.Statement=DEBUG  
log4j.logger.java.sql.PreparedStatement=DEBUG 


Mybatis.xml配置文件
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 配置别名：在MyBatis中为一个类取别名   配置别名是为了在对象映射文件中接收参数类型和返回参数类型时使用-->
    <typeAliases>
        <!--设置包下所有类名的别名，默认是类名小写-->
        <package name="com.shsxt.crm.po"/>
        <package name="com.shsxt.crm.query"/>
        <package name="com.shsxt.crm.dto"/>
    </typeAliases>

    <plugins>
        <!-- com.github.pagehelper为PageHelper类所在包名 -->
        <plugin interceptor="com.github.pagehelper.PageHelper">
            <property name="dialect" value="mysql" />
            <!-- 该参数默认为false -->
            <!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 -->
            <!-- 和startPage中的pageNum效果一样 -->
            <property name="offsetAsPageNum" value="true" />
            <!-- 该参数默认为false -->
            <!-- 设置为true时，使用RowBounds分页会进行count查询 -->
            <property name="rowBoundsWithCount" value="true" />
            <!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 -->
            <!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） -->
            <property name="pageSizeZero" value="true" />
            <!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->
            <!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->
            <!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->
            <property name="reasonable" value="true" />
            <!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 -->
            <!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 -->
            <!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 -->
            <property name="params"  value="pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql" />
        </plugin>
    </plugins>
</configuration>



Servlet-content.xml配置文件
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- 扫描com.shsxt.crm 下包 -->
    <!-- springmvc只维护管理controller -->
    <context:component-scan base-package="com.shsxt.crm.controller" />
    <aop:aspectj-autoproxy/>
    <bean id="freemarkerConfig"
          class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
        <property name="templateLoaderPath" value="/WEB-INF/views/" />
        <property name="defaultEncoding" value="UTF-8" />
    </bean>
    <bean
            class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
        <property name="prefix" value="" />
        <property name="suffix" value=".ftl" />
        <property name="contentType" value="text/html;charset=UTF-8" />
    </bean>

    <!-- mvc 注解驱动 并添加json 支持 -->
    <mvc:annotation-driven>
        <mvc:message-converters>

            <!-- 返回信息为字符串时 处理 -->
            <bean class="org.springframework.http.converter.StringHttpMessageConverter"></bean>
            <!-- 将对象转换为json 对象 -->
            <bean
                    class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"></bean>
        </mvc:message-converters>
    </mvc:annotation-driven>

    <!-- 静态资源文件的处理放行 配置方式一 -->
     <mvc:default-servlet-handler />

    <!-- 静态资源放行处理配置方式二 -->
    <mvc:resources location="/css/" mapping="/css/**"></mvc:resources>
    <mvc:resources location="/images/" mapping="/images/**"></mvc:resources>
    <mvc:resources location="/jquery-easyui-1.3.3/" mapping="/jquery-easyui-1.3.3/**"></mvc:resources>
    <mvc:resources location="/js/" mapping="/js/**"></mvc:resources>
    
    
    <mvc:interceptors>
        <mvc:interceptor>
            <mvc:mapping path="/**"/>
            <mvc:exclude-mapping path="/index"/>
            <mvc:exclude-mapping path="/user/login"/>
            <mvc:exclude-mapping path="/css/**"/>
            <mvc:exclude-mapping path="/images/*"/>
            <mvc:exclude-mapping path="/jquery-easyui-1.3.3/*"/>
            <mvc:exclude-mapping path="/jquery.easyui.min.js"/>
            <mvc:exclude-mapping path="/jquery.easyui.js"/>
            <mvc:exclude-mapping path="/js/*"/>
            <bean class="com.shsxt.crm.interceptors.LoginInterceptor"></bean>
        </mvc:interceptor>
    </mvc:interceptors>
    
    
</beans>


Spring的配置文件
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:task="http://www.springframework.org/schema/task"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/task
        http://www.springframework.org/schema/task/spring-task.xsd">

    <!-- 定时任务驱动 -->
    <task:annotation-driven />

    <!-- spring管理除了controller之外的所有bean -->
    <context:component-scan base-package="com.shsxt">
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    <context:property-placeholder location="classpath:jdbc.properties" />

    <!-- 配置数据源 -->
    <!-- 配置c3p0 数据源 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driver}"></property>
        <property name="jdbcUrl" value="${jdbc.url}"></property>
        <property name="user" value="${jdbc.username}"></property>
        <property name="password" value="${jdbc.password}"></property>
    </bean>
    <!-- 配置事务管理器 -->
    <bean id="txManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!-- 设置事物增强 -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true" />
            <tx:method name="find*" read-only="true" />
            <tx:method name="query*" read-only="true" />
            <tx:method name="load*" read-only="true" />
            <tx:method name="add*" propagation="REQUIRED" />
            <tx:method name="insert*" propagation="REQUIRED" />
            <tx:method name="update*" propagation="REQUIRED" />
            <tx:method name="del*" propagation="REQUIRED" />
            <tx:method name="save*" propagation="REQUIRED" />
        </tx:attributes>
    </tx:advice>
    <!-- aop 切面配置 -->
    <aop:config>
        <aop:pointcut id="servicePointcut"
                      expression="execution(* com.shsxt.crm.service..*.*(..))" />
        <aop:advisor advice-ref="txAdvice" pointcut-ref="servicePointcut" />
    </aop:config>
    <!-- 配置 sqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"></property>
        <property name="configLocation" value="classpath:mybatis.xml"></property> <!-- 加载mybatis -->
        <property name="mapperLocations" value="classpath:com/shsxt/crm/mapper/*.xml" />
    </bean>

    <!-- 配置扫描器 -->
    <bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 扫描com.shsxt.dao这个包以及它的子包下的所有映射接口类 -->
        <property name="basePackage" value="com.shsxt.crm.dao" />
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
    </bean>
</beans>

 
以及webdefault.xml


Pom.xml依赖
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.shsxt</groupId>
  <artifactId>shsxt_crm</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>shsxt_crm Maven Webapp</name>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>
    <!-- spring 核心jar -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- spring 测试jar -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- spring jdbc -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- spring事物 -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- aspectj切面编程的jar -->
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.8.9</version>
    </dependency>


    <!-- c3p0 连接池 -->
    <dependency>
      <groupId>c3p0</groupId>
      <artifactId>c3p0</artifactId>
      <version>0.9.1.2</version>
    </dependency>

    <!-- mybatis -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.4.1</version>
    </dependency>

    <!-- 添加mybatis与Spring整合的核心包 -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.0</version>
    </dependency>
    <!-- mysql 驱动包 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.39</version>
    </dependency>

    <!-- 日志打印相关的jar -->
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.2</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.2</version>
    </dependency>


    <dependency>
      <groupId>com.github.pagehelper</groupId>
      <artifactId>pagehelper</artifactId>
      <version>4.1.0</version>
    </dependency>

    <!-- springmvc 依赖jar -->

    <!-- spring web -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- spring mvc -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>

    <!-- web servlet -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.0.1</version>
    </dependency>
    <!-- 添加json 依赖jar包 -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-core</artifactId>
      <version>2.7.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.7.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-annotations</artifactId>
      <version>2.7.0</version>
    </dependency>
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.3.2</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context-support </artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.freemarker</groupId>
      <artifactId>freemarker</artifactId>
      <version>2.3.21</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.3.2</version>
    </dependency>
    <!-- fastjson配置 -->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>fastjson</artifactId>
      <version>1.2.13</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
    <dependency>
      <groupId>commons-codec</groupId>
      <artifactId>commons-codec</artifactId>
      <version>1.9</version>
    </dependency>


  </dependencies>
  <build>
    <finalName>crm</finalName>
    <!-- 方式一 -->
    <resources>
      <resource>
        <directory>src/main/resources</directory>
      </resource>
      <resource>
        <directory>src/main/java</directory>
        <includes>
          <include>**/*.xml</include>
          <include>**/*.properties</include>
          <include>**/*.tld</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>
    <plugins>
      <plugin>
        <groupId>org.mortbay.jetty</groupId>
        <artifactId>maven-jetty-plugin</artifactId>
        <version>6.1.25</version>
        <configuration>
          <scanIntervalSeconds>10</scanIntervalSeconds>
          <contextPath>/crm</contextPath>
          <webDefaultXml>src/main/resources/webdefault.xml</webDefaultXml>
        </configuration>
      </plugin>
      <!-- 指定编译的虚拟机 -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
          <encoding>utf8</encoding>
          <compilerArguments>
            <bootclasspath>${java.home}/lib/rt.jar</bootclasspath>
          </compilerArguments>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.mybatis.generator</groupId>
        <artifactId>mybatis-generator-maven-plugin</artifactId>
        <version>1.3.2</version>
        <configuration>
          <configurationFile>src/main/resources/generatorConfig.xml</configurationFile>
          <verbose>true</verbose>
          <overwrite>true</overwrite>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
          </dependency>
        </dependencies>
      </plugin>

    </plugins>
  </build>
</project>



js.jsp.及java代码获取项目路径的方式
//jsp页面获取
<%--声明为jsp的编程语言与编码格式--%>
<%@ page language="java" contentType="text/html;charset=UTF-8"  pageEncoding="UTF-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %><%--el表达式标签库--%>
<c:set var="ctx" value="${pageContext.request.contextPath }"></c:set> <%--根据需求通过jsp内置对象获取项目路径--%>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %><%--格式化日期format--%>




1）
访问登录页
@Controller
public class IndexController {

    @RequestMapping("index")
    public String index(HttpServletRequest request){
        request.setAttribute("ctx", request.getContextPath());
        System.out.println(request.getContextPath());
        return "index";
    }
}

2）访问主页
@Controller
public class MainController {

    @RequestMapping("main")
    public String index(HttpServletRequest request){
        request.setAttribute("ctx", request.getContextPath());
        return "main";
    }
}

4,用户登录
思路（流程）：用户输入用户名和密码->js非空校验->发送请求->后台参数校验（非空检验 唯一）->通过用户名查找用户->如果没有，就返回；有就判断密码是否正确(加密密码)->返回登录结果->前台接收返回结果，如果成功跳转到main页面，不成功挑战到指定错误页面->
sql:
<!-- 通过用户名查找用户 -->
<select id="queryUserByName" parameterType="string" resultMap="BaseResultMap">
  select <include refid="Base_Column_List"/> from t_user WHERE is_valid=1 and user_name = #{userName}
</select>

接口:
@Repository
public interface UserMapper {
    public User queryUserByName(String userName);
}

service:
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    /**
     * 用户登陆
     * @param userName 用户名
     * @param usePwd 密码
     */
    public void login(String userName, String usePwd){
        /***
         * 1. 参数校验 非空
         * 2. 查询用户通过用户名
         * 3. 校验密码是否正确 ,注意加密
         * */

        AssertUtil.isTrue(StringUtils.isBlank(userName), "用户名为空");
        AssertUtil.isTrue(StringUtils.isBlank(usePwd), "密码为空");
        User user = userMapper.queryUserByName(userName);
        AssertUtil.isTrue(null == user, "用户或密码不正确");
        AssertUtil.isTrue(!user.getUserPwd().equals(Md5Util.encode(usePwd)), "用户或密码不正确");

    }
}

controller:
@Controller
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping("login")
    @ResponseBody
    public ResultInfo login(String userName, String userPwd){
        ResultInfo info = new ResultInfo();
        try {
            userService.login(userName, userPwd);
            info.setCode(200);
            info.setMsg("登陆成功");
        } catch (ParamsException e) {
            e.printStackTrace();
            info.setCode(300);
            info.setMsg(e.getMsg());
        } catch (Exception e) {
            e.printStackTrace();
            info.setCode(300);
            info.setMsg(e.getMessage());
        }
        return info;
    }
}

js:
// 登陆
function login() {
    /***
     * 1. 获取输入框的值, 进行非空校验
     * 2. 发送ajax请求
     * */
    var username = $('#username').val();
    var password = $('#password').val();

    if(isEmpty(username)){
        alert("用户名为空");
        return;
    }

    if(isEmpty(password)){
        alert("密码为空");
        return;
    }

    $.ajax({
        url: ctx + "/user/login",
        type: 'post',
        data:{
            userName: username,
            userPwd: password
        },
        success:function (data) {
            //console.log(data);
            if(data.code==200){
                alert(data.msg);
                // 跳转到主页
                window.location.href = ctx + "/main";
            }else{
                alert(data.msg);
            }
        }
    });

}
5.用户登录状态
通过cookie记录用户的登录信息
1.浏览器在本地存储的一个文件
2.Cookie信息会在每次请求后台时，进行携带。
3.不安全
思路：当用户登录成功后->返回用户基本信息（id加密字符串）->
前台获取用户信息存入cookie->通过拦截器过滤用户请求->如果已经登录放开请求，未登录拦截请求跳转到登录页。
6.用户退出
思路：点击退出按钮，弹窗提示->点击确定，清楚cookie，跳转到登录页
// 用户退出
function logout() {
    /***
     * 1. 清除cookie
     * 2. 跳转到登录页
     * */
    $.messager.confirm('来自crm', '您想要退出该系统吗？', function(r){
        if (r){
            // 退出操作;
            $.removeCookie("userIdStr");
            window.location.href = ctx + "/index";
        }
    });
}

7.修改密码
思路：弹窗输入 旧密码新密码确认密码->后台校验（非空 两次密码是否一致，旧密码是否正确）->修改密码（注意存入的新密码时加密后的）->前台提示，修改成功后->清楚cookie信息 ，跳到登录页
sql:
<select id="queryById" resultMap="BaseResultMap" parameterType="java.lang.Integer" >
  select 
  <include refid="Base_Column_List" />
  from t_user
  where id = #{id,jdbcType=INTEGER}
</select>
<update id="update" parameterType="com.shsxt.crm.po.User" >
  update t_user
  <set >
    <if test="userName != null" >
      user_name = #{userName,jdbcType=VARCHAR},
    </if>
    <if test="userPwd != null" >
      user_pwd = #{userPwd,jdbcType=VARCHAR},
    </if>
    <if test="trueName != null" >
      true_name = #{trueName,jdbcType=VARCHAR},
    </if>

    <if test="email != null" >
      email = #{email,jdbcType=VARCHAR},
    </if>
    <if test="phone != null" >
      phone = #{phone,jdbcType=VARCHAR},
    </if>
    <if test="isValid != null" >
      is_valid = #{isValid,jdbcType=INTEGER},
    </if>
    <if test="createDate != null" >
      create_date = #{createDate,jdbcType=TIMESTAMP},
    </if>
    <if test="updateDate != null" >
      update_date = #{updateDate,jdbcType=TIMESTAMP},
    </if>
  </set>
  where id = #{id,jdbcType=INTEGER}
</update>
dao:

public User queryById(Integer id);

public Integer update(User user);

service:
/**
 * 修改密码
 * @param oldPassword
 * @param newPassword
 * @param confirmPassword
 * @param userId
 */
public void updateUserPwd(String oldPassword, String newPassword,
                          String confirmPassword, Integer userId){
    /***
     * 1. 参数校验
     * 2. 验证旧密码是否正确
     * 3. 修改密码
     * */
    checkUserPwdParams(oldPassword, newPassword, confirmPassword);

    User user = userMapper.queryById(userId);
    AssertUtil.isTrue(null==user, "用户已注销或不存在");
    AssertUtil.isTrue(!user.getUserPwd().equals(Md5Util.encode(oldPassword)), "旧密码不正确");

    user.setUserPwd(Md5Util.encode(newPassword));// 把新密码的加密后的值给到user
    AssertUtil.isTrue(userMapper.update(user)<1,"密码修改失败");

}

private void checkUserPwdParams(String oldPassword, String newPassword, String confirmPassword) {
    AssertUtil.isTrue(StringUtils.isBlank(oldPassword), "旧密码为空");
    AssertUtil.isTrue(StringUtils.isBlank(newPassword), "新密码为空");
    AssertUtil.isTrue(!newPassword.equals(confirmPassword), "两次密码不一致");
}

controller:

@RequestMapping("updateUserPwd")
@ResponseBody
public ResultInfo updateUserPwd(String oldPassword, String newPassword,
                                String confirmPassword, HttpServletRequest request){
    // 从cookie中获取用户ID
    Integer userId = LoginUserUtil.releaseUserIdFromCookie(request);
    ResultInfo info = new ResultInfo();

    try {
        userService.updateUserPwd(oldPassword, newPassword, confirmPassword, userId);
        info.setCode(200);
        info.setMsg("修改成功");
    } catch (ParamsException e) {
        e.printStackTrace();
        info.setCode(300);
        info.setMsg(e.getMsg());
    } catch (Exception e) {
        e.printStackTrace();
        info.setCode(300);
        info.setMsg(e.getMessage());
    }
    return info;
}

// 修改密码
function openPasswordModifyDialog() {
    $('#dlg').dialog("open");
}

function modifyPassword() {

    $('#fm').form('submit', {
        url: ctx + '/user/updateUserPwd',
        onSubmit: function () {
            return $(this).form('validate');   // 返回false终止表单提交
        },
        success: function (data) {
            data = JSON.parse(data);
            //console.log(data)

            if(data.code==200){
                $.messager.alert('来自crm', data.msg, 'info',function () {
                    // 退出操作;
                    // 清除cookie
                    $.removeCookie("userIdStr");
                    // 跳转到登陆页
                    window.location.href = ctx + "/index";
                });
            }else{
                $.messager.alert('来自crm', data.msg, 'error');
            }
        }
    });

}

8.全局异常处理
回顾：
1.基于xml配置，当系统报错时，跳转到错误页面
2.基于接口，灵活没有侵入性（推荐）
3.基于注解+继承，灵活但是有侵入性
思考：请求划分？？？
把请求分为2类
1）普通页面请求
2）Json数据请求
1）思路
当请求页面报错时，跳转到错误页面；
当请求json报错时，返回包含错误信息的json;
@Component
public class GlobalExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object target, Exception ex) {
        ModelAndView mv = createDefaultModelAndView(request, ex);

        /***
         * 1. 区分 页面请求和json请求
         *      通过target 目标方法, 获取方法上的注解.判断是否有@ResponseBody
         *      如果有@ResponseBody就是json请求,否是就是普通页面请求
         * */

        if(target instanceof HandlerMethod){
            HandlerMethod handler = (HandlerMethod) target;
            Method method = handler.getMethod();
            ResponseBody responseBody = method.getAnnotation(ResponseBody.class);

            if(null==responseBody){// 普通页面请求

                if(ex instanceof ParamsException){
                    ParamsException e = (ParamsException) ex;
                    mv.addObject("errorMsg", e.getMsg());
                }

            }else{// json 请求
                /***
                 * 1. 创建ResultInfo对象
                 * 2. 把对象转为json字符串
                 * 3. 通过response响应到页面
                 * */
                ResultInfo info = new ResultInfo();
                info.setCode(300);// 报错编码
                info.setMsg("系统繁忙");// 默认报错信息

                if(ex instanceof ParamsException){
                    ParamsException e = (ParamsException) ex;
                    info.setCode(e.getCode());
                    info.setMsg(e.getMsg());
                }

                // 设置响应头信息
                response.setCharacterEncoding("utf-8");
                response.setContentType("application/json;charset=utf-8");

                PrintWriter pw = null;

                try {
                    pw = response.getWriter();
                    pw.write(JSON.toJSONString(info));
                    pw.flush();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    pw.close();
                }

            }
        }


        return mv;
    }

    private ModelAndView createDefaultModelAndView(HttpServletRequest request, Exception ex) {
        ModelAndView mv = new ModelAndView();
        // 设置默认信息
        mv.setViewName("error");// 默认错误视图
        mv.addObject("errorMsg", ex.getMessage());// 默认错误信息
        mv.addObject("ctx", request.getContextPath());// 上下文路径
        return mv;
    }
}


9.优化controller
public class BaseController {


    public ResultInfo success(String msg){
        ResultInfo info = new ResultInfo();
        info.setMsg(msg);
        return info;
    }
    public ResultInfo success(String msg, Object result){
        ResultInfo info = new ResultInfo();
        info.setMsg(msg);
        info.setResult(result);
        return info;
    }
    public ResultInfo success(Integer code, String msg, Object result){
        ResultInfo info = new ResultInfo();
        info.setCode(code);
        info.setMsg(msg);
        info.setResult(result);
        return info;
    }



    /**
     * 前置处理方法
     * @param request
     */
    @ModelAttribute
    public void preMethod(HttpServletRequest request){
        request.setAttribute("ctx", request.getContextPath());
    }

}
通过拦截器过滤用户请求
拦截器：顾名思义，就是对请求进行拦截，做一些预处理、后处理或返回处理的操作 
Spring MVC中使用拦截器的方法，继承HandlerInterceptorAdapter类，并根据需求实现其中的preHandle方法（预处理）、postHandle方法（返回处理），afterCompletion方法（后处理）。
public class LoginInterceptor extends HandlerInterceptorAdapter {

    @Autowired
    private UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {
        /***
         * 判断用户是否登陆
         * */
        Integer userId = LoginUserUtil.releaseUserIdFromCookie(request);// 从请求中拿到cookie信息

        AssertUtil.isNotLogin(null==userId || null==userService.queryById(userId),"用户未登录");

        return true;
    }
}

新增未登录异常:

public class LoginException extends RuntimeException {

    private Integer code = 300;
    private String msg = "用户未登录";

    public LoginException() {
    }

    public LoginException(Integer code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    public LoginException(Integer code) {
        super("登陆异常");
        this.code = code;
    }

    public LoginException(String msg) {
        super(msg);
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}

添加断言:
public static void isNotLogin(boolean flag, String msg){
    if(flag){
        throw new LoginException(msg);
    }
}

添加全局异常处理:
/**
 * 用户未登录异常处理
 */
if(ex instanceof LoginException){
    LoginException e = (LoginException) ex;
    mv.setViewName("login_error");
    mv.addObject("errorMsg", e.getMsg());
    return mv;
}

SpringMVC 配置:
<!-- 配置拦截器 -->
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/**"/>
        <mvc:exclude-mapping path="/index"></mvc:exclude-mapping><!-- 登陆页面 -->
        <mvc:exclude-mapping path="/user/login"></mvc:exclude-mapping><!-- 登陆接口 -->
        <mvc:exclude-mapping path="/css/*"/>
        <mvc:exclude-mapping path="/images/*"/>
        <mvc:exclude-mapping path="/jquery-easyui-1.3.3/*"/>
        <mvc:exclude-mapping path="/js/*"/>
        <bean class="com.shsxt.crm.interceptors.LoginInterceptor"></bean>
    </mvc:interceptor>
</mvc:interceptors>

页面:
<#include "common.ftl" >
  <script type="text/javascript">
    alert('${errorMsg}');
    window.location.href="${ctx}/index";

    <#--if('${uri}'=="/main"){-->
       <#--window.location.href="${ctx}/index";-->
    <#--}else{-->
       <#--window.parent.location.href="${ctx}/index";-->
    <#--}-->
    
  </script>



1）Bug06: 页面嵌套显示

PS: 在一个页面中包含多个子页面,子页面通过iframe进行嵌套

if('${uri}'.indexOf("/main")>-1){
   window.location.href="${ctx}/index";
}else{
   window.parent.location.href="${ctx}/index";
}

Er.营销管理
1）页面2）数据库表
1．营销机会管理-查询
1) Bug07: typeMismatch
Field error in object 'saleChanceQuery' on field 'createDate': rejected value []; codes [typeMismatch.saleChanceQuery.createDate,typeMismatch.createDate,typeMismatch.java.util.Date,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [saleChanceQuery.createDate,createDate]; arguments []; default message [createDate]]; default message [Failed to convert property value of type [java.lang.String] to required type [java.util.Date] for property 'createDate'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.util.Date] for value ''; nested exception is java.lang.IllegalArgumentException

不能将data类型转换成string类型
解决: 通过字符串接收date
//查询
<select id=”queryByParams” parameterType=”SaleChanceQuery” resultMap=”BaseResultMap”>
Select * from t_sale_chance <where> is_valid=1
<if test=”null!=customerName and ‘’!=customerName”>
And customer_name like concat(‘%’,#{customerName},’%’)
</if>
<if test=”null!=state”>
And state =#{state}
</if>
 <if test="null!=devResult">
      and dev_result=#{devResult}
    </if>
    <if test="null!=createDate and ''!=createDate">
      and create_date &lt;= #{createDate}
    </if>
  </where>
</select>

@RequestMapping("querySaleChancesByParams")
@ResponseBody
public Map<String, Object> querySaleChancesByParams(
        Integer page,
        Integer rows,
        SaleChanceQuery query){
    query.setPageNum(page);
    query.setPageSize(rows);
    return saleChanceService.queryForPage(query);
}

page 和 rows 是easyui组件, 自带参数!
//查询
function querySaleChancesByParams() {
    $('#dg').datagrid('load', {
        customerName: $('#customerName').val(),
        state: $('#state').combobox('getValue'),
        devResult: $('#devResult').combobox('getValue'),
        createDate: $('#time').datebox('getValue')
    });
}
// 格式化显示
/**
 * @param value  字段值。
 * @param row 行记录数据。
 * @param index 行索引。
 */
function formatState(value,row,index) {
    if(value==0){
        return "未分配"
    }
    if(value==1){
        return "已分配"
    }
}

function formatDevResult(val) {
    if(val==0){
        return "未开发"
    }
    if(val==1){
        return "开发中"
    }
    if(val==2){
        return "开发成功"
    }
    if(val==3){
        return "开发失败"
    }
}

// 更改背景颜色
$(function () {
    // 当页面加载完成后再执行
    $('#dg').datagrid({
        rowStyler: function(index,row){
            var devResult = row.devResult;

            if (devResult == 0) {
                return "background-color:#5bc0de;"; // 蓝色
            } else if (devResult == 1) {
                return "background-color:#f0ad4e;"; // 黄色
            } else if (devResult == 2) {
                return "background-color:#5cb85c;"; // 绿色
            } else if (devResult == 3) {
                return "background-color:#d9534f;"; // 红色
            }
        }
    });
});
@JsonFormat(pattern = "yyyy-MM-dd hh:mm:ss", timezone = "GMT+8")
private Date createDate;

2．营销机会管理-添加
<!-- 查询所有的客户经理-->
<!-- 查询所有的客户经理 -->
<select id="queryCustomerManagers" resultType="map">
  SELECT
  u.id,
  u.true_name as trueName
  FROM
  t_role AS r
  LEFT JOIN t_user_role AS ur ON ur.role_id = r.id
  LEFT JOIN t_user AS u ON u.id = ur.user_id
  WHERE
  r.role_name = '客户经理' AND
  u.is_valid = 1
</select>
/**
 * 保存或添加营销机会
 * @param saleChance
 * @param userId
 */
/**
 * 保存或添加营销机会
 * @param saleChance
 * @param userId
 */
public void saveOrUpdateSaleChance(SaleChance saleChance, Integer userId){
    /***
     * 1. 参数校验
     * 2. 参数补全
     * 3. 执行操作
     * */

    AssertUtil.isTrue(StringUtils.isBlank(saleChance.getCustomerName()),"客户名称为空");
    AssertUtil.isTrue(StringUtils.isBlank(saleChance.getLinkMan()),"联系人为空");
    AssertUtil.isTrue(StringUtils.isBlank(saleChance.getLinkPhone()),"联系电话为空");

    User user = userMapper.queryById(userId);
    saleChance.setCreateMan(user.getUserName());// 创建人
    saleChance.setCreateDate(new Date());// 创建时间
    saleChance.setDevResult(0);// 新增记录的开发结果为0未开发
    saleChance.setIsValid(1);// 1有效记录
    saleChance.setUpdateDate(new Date());

    /***
     * 根据是否选择分配人,初始数据不同
     * */
    String assignMan = saleChance.getAssignMan();
    if(StringUtils.isBlank(assignMan)){
        // 未选择分配人
        saleChance.setState(0);// 未分配
    }else{
        // 选择了分配人
        saleChance.setAssignTime(new Date());// 分配时间
        saleChance.setState(1);// 已分配
    }


 AssertUtil.isTrue(saleChanceMapper.save(saleChance)<1, "营销机会添加失败");

}

// 添加
function openAddSaleChacneDialog () {
    $('#dlg').dialog('open')
}

function saveOrUpdateSaleChance() {

    $('#fm').form('submit', {
        url: ctx + '/saleChance/saveOrUpdateSaleChance',
        onSubmit: function () {
            return $(this).form('validate');   // 返回false终止表单提交
        },
        success: function (data) {
            data = JSON.parse(data);
            //console.log(data)

            if(data.code==200){
                // 关闭弹窗
                $('#dlg').dialog('close');
                // 清空表单数据
                $('#fm').form('clear');
                // 刷新表格数据
                $('#dg').datagrid('load');
            }else{
                $.messager.alert('来自crm', data.msg, 'error');
            }
        }
    });
}

3．营销机会管理-更新
//更新
//更新
function openModifySaleChanceDialog() {
    var rows = $('#dg').datagrid('getSelections');
    //console.log(rows);
    if(rows.length==0){
        $.messager.alert('来自crm','请选择一条数据进行更新');
        return;
    }
    if(rows.length>1){
        $.messager.alert('来自crm','只能选择一条数据进行更新');
        return;
    }
 $('#fm').form('load',rows[0]);// 回显数据
 $('#dlg').dialog('open');//显示弹窗
}

* 3. 根据ID判断添加或者更新
*      1> 如果没有id, 就是添加
*      2> 如果有id, 就是更新
if(null==id){
    // 添加
    .....
}else{
    // 更新
    AssertUtil.isTrue(saleChanceMapper.update(saleChance)<1, "营销机会更新失败");
}



4．营销机会管理-删除
使用假删除：通过一个标志位来表示数据是否删除
//批量删除
<update id=”deleteBatch”>
   Update t_sale_chance set is_valid=0 where id in (
  <foreach collection=”array” item=”item” separator=”,”>
   #{item}
  </foreach>
)
</update>
@RequestMapping("deleteSaleChanceBatch")
@ResponseBody
public ResultInfo deleteSaleChanceBatch(Integer[] ids){
    saleChanceService.deleteBatch(ids);
    return success("操作成功");
}
//删除操作
Var idstr = “”;
For(var i = 0;i<rows.length;i++){
  Idstr+=’ids=’+rows[i].id+’&’;
}





5．封装通用crud.js
宗旨：把固定的代码留下，把动态变化的代码通过参数传入
/**
 * 基本crud 通用的js 代码
 */
/**
 * 打开对话框
 * @param dlgId
 * @param title
 */

Function openAddOrUpdateDlg(dlgId,title) {
$(“#”+dlgId).dialog(“open”).dialog(“setTille”,title);
} 
Function closeDlgDate(dlgid){
  $(“#”+dlgId).dialog(“close”);
}
/**
 * 保存与更新方法封装
 * @param formId
 * @param saveOrUpdateUrl
 * @param dialogId
 * @param searchByParams
 */
function saveOrUpdate(formId,saveOrUpdateUrl,dialogId,searchByParams){
  $(“#”+formId).form(“submit”,{
     Url:saveOrUpdateUrl,
Onsubmit:function(){
//jquery 风格验证表单提交是否为空
  Return $(this).form(“validate”);

},
Success:function(data){

JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串，返回包含 JSON 文本的字符串
JSON.parse()【从一个字符串中解析出json对象】
Data = JSON.parse(data);
if（data.code==200）{
closeDlgData(dialogId);
searchByParams();
}else{
$.messager.alert(“来自crm”,data.msg,”error”);
}
}


})

}

Function openModifyDialog(dataGrdidId,formId,dialogId,title){
   Var rows = $(“#”+dataGrdidId).datagrid(“getSelections”);
 if(rows.length==0){
        $.messager.alert("来自crm","请选择一条记录进行更新!");
        return ;
    }
    if(rows.length>1){
        $.messager.alert("来自crm","只能选择一条记录进行更新!");
        return ;
    }

 /**
     * 更新操作
     */
    $("#"+formId).form("load",rows[0]);//填充表单数据  数据
 openAddorUpdateDlg(dialogId,title);
Function deleteDate(dataGridId,deleteUrl,searchByParams){
Var rows =$(“#”+dataGridId).datagrid(“getSelections”);
If(rows.length==0){
$.messager.alert(“来自crm”,”请至少选中一条记录进项删除”)；
Return；
}
$.messager.confirm(“来自crm”,”确定删除选中的”+rows.length+”条记录”，function(r){
   If(r){
   Var ids = “ids=”;
  For(var i=0;i<rows.length;i++){
   If(i<=rows.length-2){
    Ids=ids+rows[i].id+”&ids=”;
}else{
Ids=ids+rows[i].id;
}
$.ajax({
  Type:”post”,
Url:deleteUrl,
Data:ids,
dataType:”json”,
Success:function (data){
If(data.code==200){
//刷新datagrid
SearchBypARAMS();
}ELSE{
$.Messager.alert(“来自crm”,data.msg,”error”);
}
}
})
}
}
})

}


}


6．客户开发计划


二、权限管理
1．权限”三要素”
用户 -- 角色 --模块
用户与角色：多vs多
角色与模块：多vs多

2、用户管理-查询
查询用户时，要一起显示用户的角色？
当同一个用户拥有多个角色时，要合并显示角色信息？
SELECT
u.*,
GROUP_CONCAT(r.role_name) role_name
FROM
t_user AS u
LEFT JOIN t_user_role AS ur ON ur.user_id = u.id
LEFT JOIN t_role AS r ON r.id = ur.role_id
WHERE
u.is_valid = 1
GROUP BY
u.id

2．用户管理-添加
角色下拉回显？
SELECT
t_role.id,
t_role.role_name as roleName
FROM
t_role
WHERE
t_role.is_valid = 1

Q2: 添加用户,同时添加角色信息? 
需要操作t_user_role中间表

Q3: 添加用户,需要获取新用户的id?

3．用户管理
Q1: 更新用户时, 角色更新的问题?
A -> AB  添加
A -> B   删除,添加
AB -> AC ....
“一刀切”: 先把原有角色全部删除, 在批量添加新角色!
Sql添加：
Group_concat(r.role_name) role_name,
Group_concat(r.id) roleIdStr 
From t_user as u 
UserDto.java添加
Public class UserDto extends User{
   Private String roleName;
   Private String roleStr;//roleId字符串
Private List<Integer> roleIds = new ArrayList<>();roleId的集合

}
重写service的分页方法
public Map<String, Object> queryForPage(UserQuery baseQuery) throws DataAccessException {
    PageHelper.startPage(baseQuery.getPageNum(),baseQuery.getPageSize());
    List<UserDto> entities=userMapper.queryByParams(baseQuery);
    PageInfo<UserDto> pageInfo=new PageInfo<UserDto>(entities);
    Map<String,Object> map=new HashMap<String,Object>();

    /****
     * 把 字符串 "1,2,3" -> [1,2,3]
     * */

    List<UserDto> userDtoList = pageInfo.getList();
    for(UserDto userDto : userDtoList){
        String roleIdStr = userDto.getRoleIdStr();
        if(!StringUtils.isBlank(roleIdStr)){
            String[] roldIdArr = roleIdStr.split(",");
            List<Integer> roleIds = userDto.getRoleIds();
            for(String roleId : roldIdArr){
                roleIds.add(Integer.valueOf(roleId));
            }
        }
    }

    map.put("total",pageInfo.getTotal());
    map.put("rows",pageInfo.getList());
    return map;
}


1.角色更新
2.用户更新
3.如何保证用户的名字不能修改
Id无法改变。通过id查询用户的名字，如果查询的名字与当前更新懂得名字不一致，则报错！！
String curName = userMapper.queryByid(id).getUserName();
AssertUtil.isTrue(!UserName().equals(curName),”用户名不予许被修改”)；
AssertUtil.isTrue(userMapper.updata(user)<1,CrmConstant.OPS_FAILED_MSG);

//删除原有的角色（删除之前，先查询是否有需要删除的角色）
//添加新角色
Integer total = UserRoleMapper.queryUserRoleTotal(id);
If(total>0){
AssertUtil.isTrue(UserRoleMapper.deleteAllRoleByUserId(id)<total,CrmConstant.OPS_FAILED_MSG);
}
4．用户管理-删除
1.t_user 主表 假删除
2.t_user_role 中间表 真删除

5．角色管理-CRUD
6．zTree使用
Q1: 简单json树和标准json树的区别?
标注json树


Q2: 使用可勾选的树?
Setting check chkbox Type={“Y”:”ps”,”N”:”ps” };


Q3:json树的数据说明？
{id:2,pid:0,name:”随意勾选 2”，checked:true,open:true},
Id:节点id
Pid:父节点Id
Name:节点名称
Checked:是否勾选
Open:是否展开节点
<!DOCTYPE html>
<HTML>
<HEAD>
    <TITLE> ZTREE DEMO - checkbox</TITLE>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="zTree_v3-3.5.32/css/zTreeStyle/zTreeStyle.css" type="text/css">
    <script type="text/javascript" src="zTree_v3-3.5.32/js/jquery-1.4.4.min.js"></script>
    <script type="text/javascript" src="zTree_v3-3.5.32/js/jquery.ztree.core.js"></script>
    <script type="text/javascript" src="zTree_v3-3.5.32/js/jquery.ztree.excheck.js"></script>

Var setting = {check:{
     Enable:true,
     chkboxType:{“y”:”ps”,”N”:”ps”}
},
  Data:{
   simpleData:{
   Enable:true
}
}
};

 var zNodes =[
            { id:1, pId:0, name:"随意勾选 1"},
            { id:11, pId:1, name:"随意勾选 1-1"},
            { id:111, pId:11, name:"随意勾选 1-1-1"},
            { id:112, pId:11, name:"随意勾选 1-1-2"},
            { id:12, pId:1, name:"随意勾选 1-2"},
            { id:121, pId:12, name:"随意勾选 1-2-1"},
            { id:122, pId:12, name:"随意勾选 1-2-2"},
            { id:2, pId:0, name:"随意勾选 2", checked:true},
            { id:21, pId:2, name:"随意勾选 2-1"},
            { id:22, pId:2, name:"随意勾选 2-2"},
            { id:221, pId:22, name:"随意勾选 2-2-1", checked:true},
            { id:222, pId:22, name:"随意勾选 2-2-2"},
            { id:23, pId:2, name:"随意勾选 2-3"}
        ];

        $(document).ready(function(){
            $.fn.zTree.init($("#treeDemo"), setting, zNodes);
        });
        //-->
    </SCRIPT>
</HEAD>

<BODY>
<ul id="treeDemo" class="ztree"></ul>
</BODY>
</HTML>


Q4.如何判断角色是否有模块权限
Select m.id,m.module_name as name,
M.parent_id as pid,p.role_id as checked from t_module as m leaf join t_permission Asp.module_id = m.id AND p.role_id = 22
WHERE
m.is_valid = 1


少加@ResponseBody

7．角色管理-授权
先删除角色所在的模块权限，再统一添加模块权限！！！注意删之前先查找是否存在权限
8．角色删除问题
9．当删除角色是：
1.删除角色和用户的中间表数据
2.删除角色和模块的权限表数据

Q1.删除时，如果报错，数据是否自动回滚？
1）spring管理那些bean:controller service(交给spring管理，做事务自动回滚) dao component
2）SpringMvc 管理那些bean:controller (交给springMvc管理)
spring配置:
<!-- spring管理除了controller之外的所有bean -->
<context:component-scan base-package="com.shsxt">
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>


Springmvc配置：
Springmvc只维护管理controller
<context:component-scan base-package="com.shsxt.crm.controller" />


10．模块管理-CRUD
11．前台权限控制
所见即所得
原理：当用户登录成功后->通过用户id查询出所拥有的权限码列表，并放入session作用域中->通过判断来显示菜单
Q1.通过用户id查询所拥有的权限码？
SELECT
p.acl_value
FROM
t_user_role AS ur
INNER JOIN t_permission AS p ON p.role_id = ur.role_id
WHERE
ur.user_id = #{userId}
Q2: 通过freemarker模板语法,动态显示页面?
参考: http://freemarker.foofun.cn/ref_builtins_sequence.html#ref_builtin_seq_contains
https://blog.csdn.net/u010398838/article/details/79978266

12．后台权限控制
1.封装权限Util进行调用
2.通过拦截器，拦截所有请求
3.通过aop进行通知（代理模式：高内聚低耦合）

思路: 定义一个自定义注解@RequestPermission -> 在controller的方法上加上自定义注解以及权限码, 把权限码和方法进行绑定  -> 当请求时,通过方法的反射获取所携带的权限码 -> 判断当前权限码是否在权限列表中
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping 
Public @interface RequestPermission{
String aclValue() default “”;
}


@Component
@Aspect
Public class PermissionAdaptor{
@Autowired
Private HttpSession session;

@Pointcut("@annotation(com.shsxt.crm.annotations.RequestPermission)")
Public void cut(){}

   @Around("cut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
1.先获取Method对象
2.通过反射获取权限码
3.判断权限列表中是否包含该权限码

       MethodSignature signature = (MethodSignature) pjp.getSignature();
     Method method = signature.getMethod();
 RequestPermission permission = method.getAnnotation(RequestPermission.class);
//getAnnotation(Class<A> annotationClass) 方法返回该元素的指定类型的注释，如果是这样的注释，否则返回null
 String aclValue = permission.aclValue();
 System.out.println("aclValue: "+aclValue);
 List<String> permissions = (List<String>) session.getAttribute(CrmConstant.USER_PERMISSIONS);

AssertUtil.isTrue(CollectionUtils.isEmpty(permissions) || !permissions.contains(aclValue), "没有权限");

Object proceed = pjp.proceed();//继续执行
Return proceed；
 
    

}
<context:component-scan base-package="com.shsxt.crm.controller" />
<aop:aspectj-autoproxy />
加在springMVC的配置文件中

}

三、客户管理
1．客户信息管理 CRUD
2．客户流失管理
思路: 
1)查询出流失客户
2)把流失客户存入客户流失表
3)通过定时任务查询流失客户

//查询流失客户
<select id=”queryLossCustomer” resultMap=”BaseResultMap”>
Select c.* from t_customer as c where c.is_valid=1 and Date_add(c.create_date,Interval 6 month) &lt; now() and c.id not in(   SELECT DISTINCT
    co.cus_id
    FROM
    t_customer_order AS co
    WHERE
    co.is_valid = 1
    AND DATE_ADD(
    co.order_date,
    INTERVAL 6 MONTH
    ) &lt; NOW()
    ) AND
c.state = 0)
</select>
3．添加定时任务
1.在spring.xml中添加命名空间,并开启定时任务(使用注解)
2.编写定时任务代码
xmlns:task="http://www.springframework.org/schema/task"
http://www.springframework.org/schema/task
http://www.springframework.org/schema/task/spring-task.xsd
 <!-- 定时任务驱动 -->
<task:annotation-driven />
四、服务管理
五、统计报表


六、项目部署
1．安装jdk1.8
1)通过yum 安装 最简单   yum install xxxx -y  
2)手动安装 
a.先下载jdk1.8.tar.gz 压缩包
b.把压缩包上传linux,并解压
c.配置java环境 (配置文件 /etc/profile),刷新配置文件
JAVA_HOME=/usr/soft/jdk1.8.0_191
PATH=$PATH:$JAVA_HOME/bin

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL

# 刷新配置文件
 source /etc/profile

service iptables status  # 查看防火墙状态
service iptables stop # 关闭防火墙

